# Writing Your Model File
Dash uses the JSON format to describe the domain models. Each JSON file is called a _Dash Model File_.

!!! warning

    If you are not familiar with JSON, we recommend you to first learn the basics of JSON before proceeding.

## Basic Rules
- In Dash, you define Entities, Attributes, and Relationships.
- The order and scope in which Entities are defined in the source code **do not matter**.
- Always use **singular nouns** for naming Entities.
- Dash uses Convention Over Configuration.
- Dash is case-insensitive.

Let's go through a series of examples to learn write Dash Model Files. The generated POCO is included as a reference.

## Basic Anatomy of a Dash Model file
The JSON content is very simple.

At its root level, there are only 2 JSON Objects: the _optional_ `Configuration` and the _required_ `Model` object:

~~~ JSON
{
    "Configuration": {
    },

    "Model": {
    }
}
~~~

Inside the `Configuration` object, you define properties related to code generation.

If this object or any of its properties are not defined, then default values will be used instead. Let's take a look at an example:

~~~ JSON
{
    "Configuration": {
        "AutogenSuffix": ".generated",
        "Header": "(c) 2020 Dash",
        "Templates": [
            {
                "Template": "./MyTemplate/EfContext",
                "Output": "./Ef",
            },
            {
                "Template": "./MyTemplates/Poco",
                "Output": "./Poco"
            }
        ]
    }
}
~~~

### AutogenSuffix
The value that will be appended after the filename, and prepended before the extension to indicate that the file was auto-generated

**data type:** `string`

**default:** `.generated`

### Header
The header that will be injected as comments in every generated file

**data type:** `string`

**default:** `<auto-generated>This code was generated by dotnet dash CLI. Manual changes to this file will be overwritten if the code is regenerated.</auto-generated>`

### Templates
Specify the templates which will be used for code generation

**data type:** Array of `string` values, or [`Template`](#Template-Object) objects

**default:**
~~~ JSON
[
    {
        "Template": "dash://efpoco",
        "Output": ".",
    },
    {
        "Template": "dash://efcontext",
        "Output": "."
    }
]
~~~

## Template Object
Each `Template` object is used to reference a single [Built-in Template](built-in-templates.md) or [Custom Template](writing-your-custom-templates.md).

Dash will use the referenced templates to generate code.

~~~ JSON
{
    "Template": "dash://efpoco",
    "Output": "./Poco"
}
~~~

### Template
The name of the template.

**data type:** [`uri`](#uri)

**default:** _No default value_

### Output
The absolute output file location, or relative to the [working directory](to-do).

**data type:** [`uri`](#uri)

**default:** `.`

### URI
To reference Templates (and other types of [Resources](to-do)), you provide a value conform to the [Uniform Resource Identifier syntax](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier).

Dash supports the following URI schemes:

| Scheme  | Read | Write | Description                                                                   |
|---------|------|-------|-------------------------------------------------------------------------------|
| dash    | Yes  | No    | Access embedded Dash resources: [Built-in Templates](./built-in-templates.md) |
| file    | Yes  | Yes   | Access local computer resources                                               |
| http(s) | Yes  | No    | Access external resources (authentication not (yet) supported)                |

## Model Object
This is where interesting things are happening. Inside the `Model` object, you can define entities, its attributes, and the relationship between various entities.

### Entity
To define an Entity, simply add a JSON object inside the `Model` object, like this:

~~~ JSON
{
    "Model": {
        "Person": {
        }
    }
}
~~~

### Attribute
To define an Attribute for an Entity, simply add a key/value pair to the Entity object like this:

~~~ JSON
{
    "Model": {
        "Person": {
            "GivenName": "Unicode",
            "FamilyName": "Unicode",
            "Age": "Int"
        }
    }
}
~~~

#### Data type syntax
The _value_ of the key/value pair defines the data type of the attribute, and must adhere to the following _Data Type Syntax_:

~~~
[dash data type][constraints]
~~~

where `[dash data type]` must be one of the following values:

| Dash data type  | .NET     | SqlServer        |
|-----------------|----------|------------------|
| `string`        | String   | varchar          |
| `unicode`       | String   | nvarchar         |
| `int`           | Int      | int              |
| `bool`          | Bool     | bit              |
| `datetime`      | DateTime | datetime         |
| `guid`          | Guid     | uniqueidentifier |

where `[constraints]` can be a mix of any of the following constraints:

| Constraint      | Description                                                                               |
|-----------------|-------------------------------------------------------------------------------------------|
| `?`             | Indicates that the attribute is Optional                                                  |
| `[length]`      | Specifies the maximum length of the attribute (only applicable to `string` and `unicode`) |
| `(=='default')` | Defines the default value of the attribute                                                |
| `:[regex]`      | A regular expression constraint                                                           |

##### Example #1
Here we define that the `Username` attribute is _Optional/Nullable_:
~~~ JSON
"Username": "string?"
~~~

##### Example #2
The `Username` attribute is defined as a string with a maximum length of 10 characters:
~~~ JSON
"Username": "string[10]"
~~~

##### Example #3
In the next example, we specify a default value `anonymous` for the `Username` attribute:
~~~ JSON
"Username": "string(=='anonymous')"
~~~

##### Example #4
In the next example, we will apply a regular expression constraint to the `Username` attribute:
~~~ JSON
"Username": "string:[a-zA-Z0-9]"
~~~

##### Example #5
Now, let's try to apply multiple constraints to the same attribute:
~~~ JSON
"Username": "string?[10](=='anonymous'):[a-zA-Z0-9]"
~~~

!!! note

    You can put the constraints in any order, except for the regular expression constraint, which must be placed as the final constraint.